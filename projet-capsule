#!/usr/bin/env python
"""
Prints data received from the Arduino.
Part of the Texturalite project.
Authors: Alexandre Quessy, Sofian Audry.
Date: 2014
Dependencies: python-twisted python-serial
"""
import logging
import random
import sys
import os
import serial
import time
from twisted.protocols.basic import LineReceiver
from twisted.internet import reactor
from twisted.internet import task
from twisted.internet.serialport import SerialPort
from twisted.python import usage
from libnagadef import mapmaposc
from libnagadef import urn
from libnagadef import audioosc

#VERBOSE = True
VERBOSE = False
MAX_SPEED = 200 # 10 seconds
MIN_OMBRE_TIME = 5 # seconds

class Timer(object):
    """
    Returns elapsed time.
    """
    def __init__(self):
        self._started = time.time()

    def elapsed(self):
        return time.time() - self._started

    def reset(self):
        self._started = time.time()


class CliOptions(usage.Options):
    """
    Parses command-line options for our applications
    """
    optParameters = [
        ['baudrate', 'b', 115200, 'Serial baudrate'],
        ['port', 'p', '/dev/ttyUSB0', 'Serial port to use'],]


class ArduinoSerialProtocol(LineReceiver):
    """
    Handles the data received from the arduino, and write to it, too.
    """
    def __init__(self, app):
        self._app = app

    def processData(self, data):
        """
        handles a single ASCII char received from the arduino.
        """
        if data == "y":
            self._app.set_hand_connected(True)
        elif data == "n":
            self._app.set_hand_connected(False)
        if VERBOSE:
            print("Received %s" % (data))

    def lineReceived(self, line):
        try:
            data = line.rstrip()
            #logging.debug(data)
            self.processData(data)
        except ValueError:
            logging.error('Unable to parse data %s' % line)
            return

    def connectionMade(self):
        self._app.connection_made_cb()


class Application(object):
    """
    Our main logic.
    """
    def __init__(self, baudrate, serial_port):
        """
        Constructor.
        """
        self._serial = None
        self.READ_INTERVAL = 0.150 # seconds
        self._arduino_connected = False
        self._print_timer = Timer()
        self._query_timer = Timer()
        self._ombres_timer = Timer()
        self._capsule_speed = 0
        self._capsule_is_idle = True

        self._ombres_videos = [
            "/home/performance/Videos/ombres-1.mov",
            "/home/performance/Videos/ombres-2.mov",
            "/home/performance/Videos/ombres-3.mov",
            "/home/performance/Videos/ombres-4.mov",
            ]

        self._voyages_videos = [
            "/home/performance/Videos/voyage-1.MOV",
            "/home/performance/Videos/voyage-2.MOV",
            "/home/performance/Videos/voyage-3.MOV",
            "/home/performance/Videos/voyage-4.MOV",
            "/home/performance/Videos/voyage-5.MOV",
            "/home/performance/Videos/voyage-6.MOV",
            "/home/performance/Videos/voyage-7.MOV",
            "/home/performance/Videos/voyage-8.MOV",
            ]

        # Stores the state of the capsule.
        self._capsule = {
            "hands": False,
            "motor": False,
            "fan": False,
            }
        self._urn = urn.UrnRandom()
        #self._init_urn()
        self._mapmaposc = mapmaposc.MapMapOsc(12345, "localhost")
        self._audioosc  = audioosc.AudioOsc()

        try:
            #logging.debug('About to open port %s' % serial_port)
            if VERBOSE:
                print('About to open port %s' % serial_port)
            self._serial = SerialPort(ArduinoSerialProtocol(self), serial_port, reactor, baudrate=baudrate)
            print('Success opening port %s' % serial_port)
        except serial.serialutil.SerialException, e:
            print('Failed opening port %s' % serial_port)
            print(e)
            sys.exit(1)

        if VERBOSE:
            print("start task")
        self._looping_call = task.LoopingCall(self._looping_call_cb)
        # XXX
        self._looping_call.start(self.READ_INTERVAL, now=False)

    # def _init_urn(self):
    #     num = len(self.get_cues())
    #     self._urn.set_size(num)

    # def get_cues(self):
    #     """
    #     Returns the list of random clips.
    #     Homme interagit avec la nature.
    #     """
    #     directory = "/home/performance/Videos"
    #     # XXX Hard-code clips here
    #     clips = [
    #         "MVI_1208.MOV",
    #         "MVI_1212.MOV",
    #         "MVI_1213.MOV",
    #         "MVI_1214.MOV",
    #         "MVI_1217.MOV",
    #         "MVI_1219.MOV",
    #         "MVI_1220.MOV",
    #         "MVI_1224.MOV",
    #         ]
    #     ret = []
    #     for v in clips:
    #         uri = os.path.join(directory, v)
    #         if not os.path.exists(uri):
    #             print("Warning: Video file not found: %s" % (uri))
    #         ret.append(uri)
    #     return ret

    def _random_in_list(self, the_list):
        random.shuffle(the_list)
        return the_list[0]

    def start_voyage(self):
        self._audioosc.set_volumes(1, 0)
        self.set_motor(True)
        self.send_playback_speed(100)
        mapping_id = 0
        
        video = self._random_in_list(self._voyages_videos)
        self._mapmaposc.play(mapping_id, video)

    def start_ombres(self):
        self._audioosc.set_volumes(0, 1)
        self.set_motor(False)
        self.send_playback_speed(100)
        mapping_id = 0
        video = self._random_in_list(self._ombres_videos)
        self._mapmaposc.play(mapping_id, video)
        self._ombres_timer.reset()

    # def play_one_clip_voyage(self):
    #     index = self._urn.pick()
    #     video_cue = self.get_cues()[index]
    #     mapping_id = 0
    #     self._mapmaposc.play(mapping_id, video_cue)

    # def play_clip_idle(self):
    #     # XXX hard-coded idle clip
    #     uri = "/home/performance/Videos/MVI_1224.MOV"
    #     mapping_id = 0
    #     self._mapmaposc.play(mapping_id, uri)

    def _looping_call_cb(self):
        """
        Called at a regular interval.
        """
        #print("_looping_call_cb")
        if not self._arduino_connected:
            print("Arduino is not connected")
            return

        # if the arduino is connected:

        if self._print_timer.elapsed() >= self.READ_INTERVAL:
            # send read (async)
            self.send_read_hands()

        print("HANDS: %s" % (self._capsule["hands"]))

        if self._capsule["hands"]:
            self._capsule_speed += 1
            if self._capsule_speed > MAX_SPEED:
                self._capsule_speed = MAX_SPEED
        else:
            self._capsule_speed -= 1
            if self._capsule_speed < 0:
                self._capsule_speed = 0

        print("SPEED: %s" % (self._capsule_speed))

        # IDLE:
        if self._capsule_speed <= 0:
            if not self._capsule_is_idle:
                self.start_ombres()
            self._capsule_is_idle = True
            return

        # VOYAGE:
        else:
            if self._capsule_is_idle:
                if self._ombres_timer.elapsed() < MIN_OMBRE_TIME:
                    return
                elif self._capsule_speed > 10:
                    # start voyage
                    #self._capsule_speed = 0
                    self.start_voyage()
                    self._capsule_is_idle = False

            #if self._capsule_speed > 40:
            # XXX
            playback_speed_percent = self._capsule_speed * 8 + 50
            self.send_playback_speed(playback_speed_percent)
            
            if self._capsule_speed >= 100:
                self.set_fan(True)
            else:
                self.set_fan(False)

            if self._capsule_speed >= 200:
                # tilt
                # boom
                self._capsule_speed = 0
                self.start_ombres()
                self.set_fan(False)
                self._capsule_is_idle = True
            return

    def send_playback_speed(self, playback_speed_percent):
        self._mapmaposc.speed(0, playback_speed_percent)

    def set_hand_connected(self, is_connected):
        self._capsule["hands"] = is_connected
        # if VERBOSE:
        #     if is_connected:
        #         print("hand yes")
        #     else:
        #         print("hand no")

    def connection_made_cb(self):
        self._arduino_connected = True

        # if self._serial is not None:
        #     self.set_motor(True)

    def set_motor(self, is_enabled):
        """
        Turn on or off the motor.
        """
        if self._capsule["motor"] == is_enabled:
            return
        else:
            print("MOTOR %s" % (is_enabled))
            self._capsule["motor"] = is_enabled

            if is_enabled:
                self.send_to_arduino("M")
            else:
                self.send_to_arduino("m")

    def set_fan(self, is_enabled):
        """
        Turn on or off the fan.
        """
        if self._capsule["fan"] == is_enabled:
            return
        else:
            print("FAN %s" % (is_enabled))
            #return
            self._capsule["fan"] = is_enabled
            if is_enabled:
                self.send_to_arduino("F")
            else:
                self.send_to_arduino("f")

    def send_read_hands(self):
        self.send_to_arduino("R")

    def send_to_arduino(self, txt):
        #data = "%s\n" % (txt)
        if VERBOSE:
            print("send %s" % (txt))
        self._serial.protocol.sendLine(txt) # transport.write(data)
        #self._serial.protocol.transport.write("%s\n" % (txt)) # transport.write(data)


def run():
    """
    Main entry of our application.
    """
    o = CliOptions()
    try:
        o.parseOptions()
    except usage.UsageError, errortext:
        logging.error('%s %s' % (sys.argv[0], errortext))
        logging.info('Try %s --help for usage details' % sys.argv[0])
        sys.exit(1)
    baudrate = o.opts['baudrate']
    port = o.opts['port']
    app = Application(baudrate, port)
    reactor.run()


if __name__ == '__main__':
    run()

