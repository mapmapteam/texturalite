#!/usr/bin/env python
"""
Prints data received from the Arduino.
Part of the Texturalite project.
Authors: Alexandre Quessy, Sofian Audry.
Date: 2014
Dependencies: python-twisted python-serial
"""
import logging
import random
import sys
import os
import serial
import time
from twisted.protocols.basic import LineReceiver
from twisted.internet import reactor
from twisted.internet import task
from twisted.internet.serialport import SerialPort
from twisted.python import usage
from libnagadef import mapmaposc
from libnagadef import urn
from libnagadef import audioosc

#VERBOSE = True
VERBOSE = False
MAX_SPEED = 200 # 10 seconds
MIN_OMBRE_TIME = 5 # seconds
FULL_TANK_GAS = 200

STATE_IDLE = 0
STATE_STARTUP = 1
STATE_TRAVELLING = 2
STATE_OUT_OF_GAS = 3
STATE_GLIDING = 4

class RandomOnOff(object):
    """
    Randomly toggles on/off.
    """
    def __init__(self, prob_to_on=0.5, prob_to_off=0.5):
        self._prob_to_on = prob_to_on
        self._prob_to_off = prob_to_off
        self._is_on = False
    
    def random(self):
        if self._is_on:
            self._is_on = random.random() <= self._prob_to_off
        else:
            self._is_on = not (random.random() <= self._prob_to_on)
        return self._is_on
    
class Timer(object):
    """
    Returns elapsed time.
    """
    def __init__(self):
        self._started = time.time()
        self._accumulated = 0
        self._is_paused = False

    def elapsed(self):
        if self._is_paused:
            return self._accumulated
        else:
            return time.time() - self._started + self._accumulated

    def reset(self):
        self._started = time.time()
        self._accumulated = 0
        self._is_paused = False
        
    def pause(self):
        self._accumulated = self.elapsed()
        self._is_paused = True
        
    def resume(self):
        self._started = time.time()
        self._is_paused = False


class CliOptions(usage.Options):
    """
    Parses command-line options for our applications
    """
    optParameters = [
        ['baudrate', 'b', 115200, 'Serial baudrate'],
        ['port', 'p', '/dev/ttyUSB0', 'Serial port to use'],]


class ArduinoSerialProtocol(LineReceiver):
    """
    Handles the data received from the arduino, and write to it, too.
    """
    def __init__(self, app):
        self._app = app
        self._hand_num_consecutive_positive = 0

    def processData(self, data):
        """
        handles a single ASCII char received from the arduino.
        """
        # XXX careful with false positives
        if data == "y":
			self._hand_num_consecutive_positive += 1
        elif data == "n":
            self._app.set_hand_connected(False)
        # this is to help allieviate problems with false positives
        if self._hand_num_consecutive_positive >= 3
			self._app.set_hand_connected(True)
		else:
			self._app.set_hand_connected(False)
        if VERBOSE:
            print("Received %s" % (data))

    def lineReceived(self, line):
        try:
            data = line.rstrip()
            #logging.debug(data)
            self.processData(data)
        except ValueError:
            logging.error('Unable to parse data %s' % line)
            return

    def connectionMade(self):
        self._app.connection_made_cb()


class Application(object):
    """
    Our main logic.
    """
    def __init__(self, baudrate, serial_port):
        """
        Constructor.
        """
        self._serial = None
        self.READ_INTERVAL = 0.150 # seconds
        self._arduino_connected = False
        self._print_timer = Timer()
        self._query_timer = Timer()
        self._ombres_timer = Timer()
        self._capsule_speed = 0
        self._capsule_gas = FULL_TANK_GAS
        self._state = STATE_IDLE
        self._state_timer = Timer()
        self._random_wobble = RandomOnOff(0.1, 0.1)
        self._random_wind = RandomOnOff(0.05, 0.005)

        self._ombres_videos = [
            os.path.expanduser("~/Videos/ombres-1.mov"),
            os.path.expanduser("~/Videos/ombres-2.mov"),
            os.path.expanduser("~/Videos/ombres-3.mov"),
            os.path.expanduser("~/Videos/ombres-4.mov"),
            ]

        self._voyages_videos = [
            os.path.expanduser("~/Videos/voyage-1.MOV"),
            os.path.expanduser("~/Videos/voyage-2.MOV"),
            os.path.expanduser("~/Videos/voyage-3.MOV"),
            os.path.expanduser("~/Videos/voyage-4.MOV"),
            os.path.expanduser("~/Videos/voyage-5.MOV"),
            os.path.expanduser("~/Videos/voyage-6.MOV"),
            os.path.expanduser("~/Videos/voyage-7.MOV"),
            os.path.expanduser("~/Videos/voyage-8.MOV"),
            ]

        # Stores the state of the capsule.
        self._capsule = {
            "hands": False,
            "motor": False,
            "fan": False,
            }
        self._urn = urn.UrnRandom()
        #self._init_urn()
        self._mapmaposc = mapmaposc.MapMapOsc(12345, "localhost")
        self._audioosc  = audioosc.AudioOsc()

        try:
            #logging.debug('About to open port %s' % serial_port)
            if VERBOSE:
                print('About to open port %s' % serial_port)
            self._serial = SerialPort(ArduinoSerialProtocol(self), serial_port, reactor, baudrate=baudrate)
            print('Success opening port %s' % serial_port)
        except serial.serialutil.SerialException, e:
            print('Failed opening port %s' % serial_port)
            print(e)
            sys.exit(1)

        if VERBOSE:
            print("start task")
        self._looping_call = task.LoopingCall(self._looping_call_cb)
        # XXX
        self._looping_call.start(self.READ_INTERVAL, now=False)

    # def _init_urn(self):
    #     num = len(self.get_cues())
    #     self._urn.set_size(num)

    # def get_cues(self):
    #     """
    #     Returns the list of random clips.
    #     Homme interagit avec la nature.
    #     """
    #     directory = "/home/performance/Videos"
    #     # XXX Hard-code clips here
    #     clips = [
    #         "MVI_1208.MOV",
    #         "MVI_1212.MOV",
    #         "MVI_1213.MOV",
    #         "MVI_1214.MOV",
    #         "MVI_1217.MOV",
    #         "MVI_1219.MOV",
    #         "MVI_1220.MOV",
    #         "MVI_1224.MOV",
    #         ]
    #     ret = []
    #     for v in clips:
    #         uri = os.path.join(directory, v)
    #         if not os.path.exists(uri):
    #             print("Warning: Video file not found: %s" % (uri))
    #         ret.append(uri)
    #     return ret

    def _random_in_list(self, the_list):
        random.shuffle(the_list)
        return the_list[0]

    def start_voyage(self):
        self._audioosc.set_volumes(1, 0)
        self.send_playback_speed(100)
        mapping_id = 0        
        video = self._random_in_list(self._voyages_videos)
        self._mapmaposc.play(mapping_id, video)

    def start_ombres(self):
        self._audioosc.set_volumes(0, 1)
        self.send_playback_speed(100)
        mapping_id = 0
        video = self._random_in_list(self._ombres_videos)
        self._mapmaposc.play(mapping_id, video)
        self._ombres_timer.reset()
    
    def change_state(self, newState):
        self._state_timer.reset()
        self._state = newState
    # def play_one_clip_voyage(self):
    #     index = self._urn.pick()
    #     video_cue = self.get_cues()[index]
    #     mapping_id = 0
    #     self._mapmaposc.play(mapping_id, video_cue)

    # def play_clip_idle(self):
    #     # XXX hard-coded idle clip
    #     uri = "/home/performance/Videos/MVI_1224.MOV"
    #     mapping_id = 0
    #     self._mapmaposc.play(mapping_id, uri)

    def _looping_call_cb(self):
        """
        Called at a regular interval.
        """
        #print("_looping_call_cb")
        if not self._arduino_connected:
            print("Arduino is not connected")
            return

        # if the arduino is connected:

        if self._print_timer.elapsed() >= self.READ_INTERVAL:
            # send read (async)
            self.send_read_hands()

        print("HANDS: %s" % (self._capsule["hands"]))
        
        # Manage motor and speed
        enable_motor = False
        enable_fan   = False
        
        if self._capsule["hands"] and self._capsule_gas > 0:
            # activate motor (with gas)
            enable_motor = True
            self._capsule_speed += 1
            self._capsule_gas -= 1
            if self._capsule_speed > MAX_SPEED:
                self._capsule_speed = MAX_SPEED
        else:
            # motor not activated (e because no hands and/or gas)
            enable_motor = False
            # out of gas: speed is constant
            if self._state == STATE_OUT_OF_GAS:
                pass
            # gliding: speed increases (!)
            elif self._state == STATE_GLIDING
                self._capsule_speed += 1
            # normal: decrease speed
            else:
                self._capsule_speed -= 1
            # we can't have negative speed
            if self._capsule_speed < 0:
                self._capsule_speed = 0
        
        # speed == wind
        if self._state != STATE_IDLE:
            if self._capsule_speed >= 100:
                enable_fan = True
            else:
                enable_fan = True

        # Manage state transitions
        if self._state == STATE_IDLE:
            # TODO: add wind in the forest
            enable_fan = self._random_wind.random()
            # Refill after 10 seconds
            if self._state_timer.elapsed() > 10:
                self._capsule_gas = FULL_TANK_GAS
            # Enough speed to start
            if self._capsule_speed > 10:
                self.start_voyage()
                self.change_state(STATE_STARTUP)
                
        elif self._state == STATE_STARTUP:
            # wobbling motor
            enable_motor = self._random_wobble.random()
            if self._capsule_speed > 50:
                self.change_state(STATE_TRAVELLING)
            
        elif self._state == STATE_TRAVELLING:
            if self._capsule_speed < 30:
                self.start_ombres()
                self.change_state(STATE_IDLE):
            if self._capsule_gas <= 0:
                self._state_timer.reset()
                self.change_state(STATE_OUT_OF_GAS)
        
        elif self._state == STATE_OUT_OF_GAS:
            # wobbling motor
            enable_motor = self._random_wobble.random()
            if self._state_timer.elapsed() > 5:
                self.change_state(STATE_GLIDING)
            
        elif self._state == STATE_GLIDING:
            # wobbling motor
            #enable_motor = self._random_wobble.random()
            if self._capsule_speed < 30:
                self.start_ombres()
                self.change_state(STATE_IDLE)
 
        else:
            print("Unknown state: %s" % (self._state))

        # activate motor and fan (for real!)
        self.set_motor(enable_motor)
        self.set_fan(enable_fan)
        
        # 
        if self._state in [ STATE_TRAVELLING, STATE_OUT_OF_GAS, STATE_GLIDING ]:
            playback_speed_percent = self._capsule_speed * 8 + 50
            self.send_playback_speed(playback_speed_percent)
        else:
            self.send_playback_speed(100)
            
        print("SPEED: %s" % (self._capsule_speed))
        # done
        
        # deprecated:
        """
        # IDLE:
        if self._capsule_speed <= 0:
            if not self._capsule_is_idle:
                self.start_ombres()
            self._capsule_is_idle = True
            return

        # VOYAGE:
        else:
            if self._capsule_is_idle:
                if self._ombres_timer.elapsed() < MIN_OMBRE_TIME:
                    return
                elif self._capsule_speed > 10:
                    # start voyage
                    #self._capsule_speed = 0
                    self.start_voyage()
                    self._capsule_is_idle = False

            #if self._capsule_speed > 40:
            # XXX
            playback_speed_percent = self._capsule_speed * 8 + 50
            self.send_playback_speed(playback_speed_percent)
            
            if self._capsule_speed >= 100:
                self.set_fan(True)
            else:
                self.set_fan(False)

            if self._capsule_speed >= 200:
                # tilt
                # boom
                self._capsule_speed = 0
                self.start_ombres()
                self.set_fan(False)
                self._capsule_is_idle = True
            return
        """

    def send_playback_speed(self, playback_speed_percent):
        self._mapmaposc.speed(0, playback_speed_percent)

    def set_hand_connected(self, is_connected):
        self._capsule["hands"] = is_connected
        # if VERBOSE:
        #     if is_connected:
        #         print("hand yes")
        #     else:
        #         print("hand no")

    def connection_made_cb(self):
        self._arduino_connected = True

        # if self._serial is not None:
        #     self.set_motor(True)

    def set_motor(self, is_enabled):
        """
        Turn on or off the motor.
        """
        #if self._capsule["motor"] == is_enabled:
        #    return
        #else:
        print("MOTOR %s" % (is_enabled))
        self._capsule["motor"] = is_enabled

        if is_enabled:
            self.send_to_arduino("M")
        else:
            self.send_to_arduino("m")

    def set_fan(self, is_enabled):
        """
        Turn on or off the fan.
        """
        #if self._capsule["fan"] == is_enabled:
        #    return
        #else:
        print("FAN %s" % (is_enabled))
        #return
        self._capsule["fan"] = is_enabled
        if is_enabled:
            self.send_to_arduino("F")
        else:
            self.send_to_arduino("f")

    def send_read_hands(self):
        self.send_to_arduino("R")

    def send_to_arduino(self, txt):
        #data = "%s\n" % (txt)
        if VERBOSE:
            print("send %s" % (txt))
        self._serial.protocol.sendLine(txt) # transport.write(data)
        #self._serial.protocol.transport.write("%s\n" % (txt)) # transport.write(data)


def run():
    """
    Main entry of our application.
    """
    o = CliOptions()
    try:
        o.parseOptions()
    except usage.UsageError, errortext:
        logging.error('%s %s' % (sys.argv[0], errortext))
        logging.info('Try %s --help for usage details' % sys.argv[0])
        sys.exit(1)
    baudrate = o.opts['baudrate']
    port = o.opts['port']
    app = Application(baudrate, port)
    reactor.run()


if __name__ == '__main__':
    run()

